cc4e

Ch0

- Heap refers to memory that C manages on our behalf when we need to borrow memory and give it back later
- its up to the programmer to give dynamic memory back
- Making good use of dynamic memory allocation
- it is independent of any particular machine architecture
- c provides pointers and the ability to do address arithmetic

Ch1

- all variables must be declared before use
- a declaration consists of a type, and a list of variables which have that type
- char - character, single byte
- short - short integer
- long - long integer
- double - double-precision floating point
- the size of these objects are machine-dependent
- it is wise to write floating point constants with explicit decimal points even when they have integral values
- scanf is like printf except it reads input instead of writing output
- for and while loops are indeterminate
- Symbolic Constants:
	- #define LOWER
	- #define UPPER
- symbolic names are written in uppercase so they can be distinguished from lower case variable names
- %ld is a long integer
- double is a double length float
- Arrays
- Scope

Ch2

2.1 Variable names:
- there are some restrictions on variable and symbolic constant names
- reserved variables
- choose variable names that make sense

2.2 Data Types and Sizes:
- char		- single byte, one character
- int		- integer
	- qualifiers:
		- short int x;
		- long int y;
		- unsigned int z;
		- int can be omitted in these cases
- float 	- single precision floating point
- double	- double precision floating point
- precision depends on the machine
- check the table in 2-2?

2.3 Constants:
- scientific notation for floats is legal
- a leading 0 on an int represents an octal
- a leading 0x represents hex
- they both can be followed by L to make them a long
- character constant is a single char written in single quotes
- constant expression is an expression that involves only constants
- quotes in a string are used as a delimiter
(check Programming Truncation Explanation in gpt)

2.4 Declarations:
- All variables must be declared before use
- a declaration specifies a type
	- int lower, upper, step;
	- char c, line[1000]
- variables can be initialized in their declaration:
	- char backslash = '\\';
	int i = 0;
	
2.5 Arithmetic Operators
- + - * / %
- % cannot be applied to float or double

2.6 Relational and Logic Operators
- Relational Operators:
	- > >= < <=
	- they all have the same precedence
- equality operators:
	- == !=
- logical connectives:
	- && ||
	- the precedence of && is higher than ||
- unary negation operator ! 
	- converts true to false and false to true
	
2.7 Type Conversions
- chars and ints can be mixed in arithmetic
- check out atoi
- check out gets function
- check out binary operators
- check out the implicit arithmetic conversions
- all floating point arithmetic in C is done in double precision
- conversions take place across assignments
	- int i;
	- char c;
	- i = c;
	- c = i;

2.8 Increment and Decrement Operators
- ++ --

2.9 Bitwise Logical Operators
- & bitwise AND
- | bitwise inclusive OR
- ^ bitwise exclusive OR
- << left shift
- >> right shift
- ~ one's compliment (unary)
- check getbits operator
- declaring the argument x to be unsigned ensures that when it is right shifted, vacated bits will be filled with zeroes and not sign bits (regardless of the machine it is ran on)
- bitwise operators play a role in encryption, decryption, and checksum calculations
****- look @ exercise 2-5? Modify getbits to number bits from left to right

2.10 Assignment Operators and Expressions
- i += 2
- check bitcount
****- look at the code in this section

2.11 Conditional Expressions
- if (a > b)
	z = a;
	else
	z = b;
- e1 ? e2 : e3
- ternary operator

2.12 Precedence and Order of Evaluation
- check the table!
- * indirection
- & address of
- check side effect operators
- writing code that depends on order of evaluation is a bad programming practice in any language!

Ch3 Control Flow


3.1 Statements and Blocks
- an expression becomes a statement when it is followed by a semicolon
	- x = 0;
	- ++i;
- the semicolon is a statement terminator
- {} are used to group statements and Declarations into blocks or compound statements
- variables can be declared inside any blocks

3.2 if-else
- if (expression)
	statement1
	else
	statement2
- else can be optional
 if (n > 0)
	if (a > b)
	z = a;
 else 
	z = b;
- this else goes with the inner if
- if that isnt what is wanted then you have to use braces to force proper association
if (n > 0){
	if (a > b)
		z = a;
} else 
	z = b;

3.3 else-if
if (expression)
	statement 
else if (expression)
	statement
else if (expression)
	statement 
else
	statement
(this last else is good for error checking)
- if expressions are evaluated in order
- Binary search function
- this decides if a particular value x occurs in the sorted array v. 
- the elements of v must be in increasing order
- the function returns the position (a number between 0 and n-1) if x occurs in v, and -1 if not
- binary search first compares the input value x to the middle element of the array v
- if x is less than the middle value, searching focuses on the lower half of the table, otherwise on the upper half
- in either case, the next step is to compare x to the middle element of the selected half
- this process of dividing the range in two continues until the value is found or the range is empty
/* binsearch: find x in v v[0] <= v[1] <= ... <= v[n-1] */

int binsearch (int x, int[v], int n)
{
	int low, high, mid;

	low = 0;
	high = n - 1;
	while (low <= high){
		mid = (low+high) / 2;
		if (x < v[mid])
			high = mid - 1;
		else if (x > v[mid])
			low = mid + 1;
		else // found match 
			return mid;
	}
	return -1; // no match
}

- the fundamental decision is whether x is less than, greater than, or equal to
	- the middle element v[mid] at each step;
		- this is perfect for an else-if
- look @ exercise 3-1

3.4 Switch
- Switch statments are a multi-way decision that tests whether an expression matches one 
	- of a number of constant integer values, and branches accordingly

switch (expression){
	case const-expr: statements
	case const-expr: statements
	default: statements
}

- each case is labeled by one or more integer valued constants or constant expressions
- all case expressions must be different
- default is executed when no other cases are satisfied
- default is optional
- cases and default can be in any order

#include <stdio.h>

int main() //count digits, white space, others
{
    int c, i, nwhite, nother, ndigit[10];

    nwhite = nother = 0;
    for (i = 0; i < 10; i++)
        ndigit[i] = 0;
    while ((c = getchar()) != EOF ){
        switch (c) {
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                ndigit[c-'0']++;
                break;
            case ' ':
            case '\n':
            case '\t':
                nwhite++;
                break;
            default:
                nother++;
                break;
        }
    }
    printf("\ndigits = ");
    for (i= 0; i < 10; i++)
        printf("%d", ndigit[i]);
    printf(", white spaces = %d, other = %d\n", nwhite, nother);
    return 0;
}

- break statement immediately ends the switch
- break and return are the most common ways to exit a switch
- you can use break in loops
- look @ exercise 3-2

3.5 Loops - While and for
while (expression)
	statement

for (expr1; expr2; expr3)
	statement

is the same as:

expr1;
while (expr2){
	statement
	expr3;
}

- for loops are preferable when there is an initialization and you need to increment
for (i = 0; i < 10; i++)
- for loops are not restricted to arithemetic progressions
- atoi for converting a string to a numeric equivalent
- the structure of this program reflects the form of the input:
skip white space, if any
get sign, if any
get integer part and convert it

#include <ctype.h>

// atoi convert s to integer; v2

int atoi(char s[])
{
    int i, n, sign;

    for (i = 0; isspace(s[i]); i++) //skip white space
        ;
    sign = (s[i] == '-') ? -1 : 1;
    if (s[i] == '+' || s[i] == '-') //skip sign
        i++;
    for (n = 0; isdigit(s[i]); i++)
        n = 10 * n + (s[i] - '0');
        return sign * n;
}

- the standard library provides a more elaborate function strtol
	- conversion from string to long int

- look up shell sort for C
- a pair of expressions separated by a comma is evaluated left to right
- the type and value of the result are the type and value of the right operand
- you can do this to process two indices in parallel

//reverse string s in place
#include <string.h>

void reverse(char s[])
{
	int c, i, j;

	for (i = 0, j = strlen(s)-1; i < j; i++, j--){
		c = s[i];
		s[i] = s[j];
		s[j] = c;
	}
}

- comma operators should be used sparingly
- a comma expression might be appropriate for the exchange of elements in reverse

3.6 Loops - Do-while

- do while tests at the bottom after making each pass through the loop body
do
	statement
while (expression);

- the statement is executed, then expression is evaluated
- can be useful in some cases like itoa (# to string)

// itoa: convert n to characters in s
void itoa(int n, char s[])
{
	int i, sign;

	if ((sign = n) < 0) //record sign
		n = -n; // make n positive
	i = 0;
	do { 	// generate digits in reverse order
		s[i++] = n % 10 + '0'; // get next digit
	} while ((n /= 10) > 0); //delete it
	if (sign < 0)
	s[i++] = '-';
	s[i] = '\0';
	reverse(s);
}

3.7 Break and Continue 
- break provides an early exit from a loop

// trim: remove trailing blanks, tabs, newlines
int trim(char s[])
{
	int n;

	for (n = strlen(s)-1; n >= 0; n--)
		if (s[n] != ' ' && s[n] != '\t' && s[n] != '\n')
		break;
	s[n+1] = '\0';
	return n;
}
- strlen returns the length of a string
- the for loop starts at the end and iterates backwards
- the loop breaks when one is found
- always verify for correct behavior
- the continue statement only applies to loops, never switch
- this fragment processes only non-negative elements in the array, a; negative values are skipped

	for (i = 0; i < n; i++){
		if (a[i] < 0) //skip negative elements
			contine;
			... // do positive elements
	}

3.8 GOTO and Labels
- Formally, goto is never necessary
	for ()
		for (){
			...
			if (disaster)
				goto error;
		}
error:
	clean up the mess 

- this organization is handy if the error-handling code in non-trivial
	- and if errors can occur in multiple places

Ch4 Functions and Program structure

- functions break large computing tasks into smaller ones
- great for creating templates
- C programs generally consist of a lot of small functions
- syntax of function definitions change, so declarations and definitions match
	- this makes it easy for the compiler to detect more errors

4.1 Basics of Functions

- remember C arrays begin at index 0
- strindex function to determine occurrence of a pattern:
#include <stdio.h>
#define MAXLINE 1000 // max input line length

int getline(char line[], int max);
int strindex(char source[], char searchfor[]);

char pattern[] = "ould"; //pattern to search for 

// find all lines matching the pattern:
int main()
{
    char line [MAXLINE];
    int found = 0;

    while(getline(line, MAXLINE) > 0)
        if (strindex(line, pattern) >= 0){
            printf("%s", line);
            found++;
        }
    return found;
}

// getline: get line into s, return length
int getline(char s[], int lim)
{
    int c, i;

    i = 0;
    while(--lim > 0 && (c=getchar()) != EOF && c != '\n')
        s[i++] = c;
    if (c == '\n')
        s[i++] = c;
    s[i] = '\0';
    return i;
}

//strindex: return index of t in s, -1 if none
int strindex(char s[], char t[])
{
    int i, j, k;

    for (i = 0; s[i] != '\0'; i++){
        for (j = i, k = 0; t[k] != '\0' && s[j] == t[k]; j++, k++);
        if (k > 0 && t[k] == '\0')
            return i;
    }
    return -1;
}

- Each function definiton has the form:
	- return-type function-name(argument declarations)
	  {
			declarations and statements
	  }
- various parts may be absent; a minimal function is 
	- dummy () {}
	- this is a do nothing function
	- can be useful as a placeholder
- a program is just a set of definitions of variables and functions
- communication between the functions is by arguments and values returned by the functions
	- and through external variables
- functions can occur in any order in the source file
	- the source program can be split into multiple files (so long as no function is split)
- return statement returns a value from the called function to its caller
	- "return expression";
	- the expression will be converted to the return type of the function if necessary
- the calling function is free to ignore the returned value
- if a function fails to return a value, its value is garbage
- multiple source files can be called upon using cc from terminal
	- ex. cc main.c getline.c strindex.C
	- it compiles the 3 files, and results in 3 .o files (object files)

4.2 Functions Returning Non-Integers
- atoi and atof
	- converts strings to numerical values
- atoi (ascii to int)
	- a function used to convert a string representing an integer (in ASCII format) into an actual integer data type. 
	- It takes a string as its argument and returns an integer
	- ex. int atoi(const char *str);
- atof (ascii to floatint-point)
	- a function used to convert a string representing a floating-point number (in ASCII format) into a floating-point data type, typically a double
	- ex. double atof(const char *str);
- these are useful for parsing and converting user input or data read from files where numbers are represented as strings

#include <ctype.h>
double my_atof(char s[])
{
    double val, power;
    int i, sign;
    
    for (i = 0; isspace(s[i]); i++); //skip white space
    sign = (s[i] == '-') ? -1 : 1;
    if (s[i] == '+' || s[i] == '-')
    i++;
    for (val = 0.0; isdigit(s[i]); i++)
        val = 10.0 * val + (s[i] - '0');
    if (s[i] == '.')
        i++;
    for (power = 1.0; isdigit(s[i]); i++){
        val = 10.0 * val + (s[i] - '0');
        power *= 10.0;
    }
    return sign * val / power;
}

- double sum, atof(char []);
	- says that sum is a double and that atof is a function that takes one char argument
- atof must be declared and defined consistently
- if atof and the call to it in main have incosistent types, you will get an error
- this can get tricky in separate compilation
- if the function takes arguments, declare them; 
	- if it takes no arguments, use void
// atoi: convert string s to int using atof
int atoi(char[s])
{
	double atof(char s[]);

	return (int) atof(s);
}

4.3 External variables
- A C program consists of a set of external objects, which are either variables or functions
- external variables are defined outside of any function
	- can be available to many Functions
- "external linkage"
	- refers to the property of a variable or function that allows it to be accessed or used from different source files (translation units) in a program. 
	- Variables and functions with external linkage have a global scope, meaning they can be used across multiple files, not just the file in which they are declared.
- apply with caution!
- pushing and popping operators and operands:
while (next operator or operand is not EOF indicator)
	if (number)
		push it
	else if (operator)
		pop operands
		do operation
		push result
	else if (newline)
		pop and print top of stack
	else 
		error

#include <stdio.h>
#include <stdlib.h> //for atof

#define MAXOP 100 //max size of operand or operator
#define NUMBER '0' //signal that a number was found

int getop(char []);
void push(double);
double pop(void);

// reverse polish calculator
int main()
{
    int type;
    double op2;
    char s[MAXOP];

    while ((type = getop(s)) != EOF){
        switch (type) {
        case NUMBER:
            push(atof(s));
            break;
        case '+':
            push(pop() + pop());
            break;
        case '*':
            push(pop() * pop());
            break;
        case '-':
            op2 = pop();
            push(pop() - op2);
            break;
        case '/':
            op2 = pop();
            if (op2 != 0.0)
                push(pop() / op2);
            else printf("error: zero divisor\n");
            break;
        case '\n':
            printf("\t%.8g\n", pop());
            break;
        default:
            printf("error: unknown command %s\n", s);
            break;           
        }
    }
    return 0;
}

- variable is external if it is defined outside of any function
- getop fetches the next operator or operand

4.4 Scope Rules
- extern declatation
- You can declare a global variable as extern in a source file to indicate that it's defined in another source file. 
	- This allows you to use the variable in the current source file without redefining it.
- there must only be one definition of an external variable among all the files that make up the source Program
	- other files may contain extern declatations to access it
- "file 1":
	extern int sp;
	extern double val[];

	void push(double f) {...}
	double pop(void) {...}
- "file2":
	int sp = 0;
	double val[MAXVAL];
- the extern declaration in file lie ahead of and outside the function definition,
	- they apply to all functions;

4.5 Header Files 
- Header files in C are used to declare the interfaces, prototypes, and declarations for functions, variables, and types that are used across multiple source files in a program. 
	- They play a crucial role in modularizing and organizing your code, promoting code reusability, and reducing the likelihood of errors. 
- Declaration of Functions and Variables
	- Header files typically contain the declarations (function prototypes) of functions and variables that are meant to be used across multiple source files.
- Code Reusability
	- Header files allow you to reuse code across multiple source files. By including a header file, you can access functions and variables defined in one source file from another.
	- This promotes code modularity and makes it easier to maintain and update your codebase.
- Avoiding Code Duplication
	- By placing common function prototypes and declarations in header files, you avoid duplicating the same declarations in multiple source files. 
	- This reduces the risk of inconsistencies and makes it easier to update the code.
- Encapsulation
	- Header files can also be used to encapsulate the implementation details of a module (source file).
	- You can hide the internal implementation details and only expose the necessary parts through the header file.
- Standard Library Headers
	- C also provides a set of standard library header files, such as <stdio.h> for input and output functions and <stdlib.h> for memory allocation functions. 
	- These headers contain prototypes and declarations for standard library functions.
- Inclusion using #include
	- To use a header file in a source file, you include it using the #include preprocessor directive. 
	- For example, #include "mylibrary.h" brings in the declarations from "mylibrary.h."

4.6 Static variables
- the static declaration limits the scope of that object to the rest of the source file being compiled
- static storage is specified by prefixing the normal declaration with the word Static
- if a function is declared static, its name is invisible outside of the file in which it is declared
- static can also be applied to internal variables
	- are local to a particular function
	- internal static variables provide private, permanent storage within a single function

4.7 Register Variables
- a register declaration advises the compiler that the variable in question will be heavily used
- the register declaration can only be applied to automatic variables and to the formal parameters of a function
- only certain types are allowed
- theyre usually used for faster access
- it isnt used much these days

4.8 Block structure
- Block structures are fundamental for organizing code, managing scope, and controlling program flow in C. 
- They help ensure that variables have well-defined lifetimes and scopes and are a key part of creating modular and maintainable C programs.

4.9 Initialization
- for external and static variables, the initializer must be a constant expression
- refers to the process of giving a variable its initial value when it is declared
- Initialization is an important aspect of C programming because it ensures that variables start with a known and often meaningful value
- when the size of an array is omitted, the compuler will compute the length by counting the initializers \
- it is an error to have too many initializers

4.10 Recursion
- In C, a function may call itself either directly or indirectly
#include <stdio.h>

// Recursive function to calculate the factorial of a number
unsigned long long factorial(int n) {
    if (n == 0) {
        return 1; // Base case: 0! = 1
    } else {
        return n * factorial(n - 1); // Recursive case: n! = n * (n-1)!
    }
}

int main() {
    int num = 52;
    unsigned long long result = factorial(num);
    printf("Factorial of %d = %llu\n", num, result);
    return 0;
}

- the standard library includes a version of qsort that can sort objects of any type
- recursive code is compact and often easier to write and understand than the non-recursive equivalent

4.11 The C Preprocessor 
- used for #include and #defined
	- #include "filename"
		- if the filename is quoted, searching begins where the source program was found
	- #include <filename>
		- searching follows an implementation defined rule to find the file
- #include is the preferred way to tie the declarations together for a large program

4.11.2 Macro Substitution
- A definition has the form
	#define name replacement text
- Macro substitution is a powerful tool in C for creating reusable and easy-to-maintain code. 
- Macros can be used to define constants, simple calculations, and even short code snippets that are used frequently. 
- However, it's important to use macros carefully and follow best practices to avoid potential pitfalls, 
	- such as unexpected behavior due to operator precedence or side effects in macro expressions.
- the ## operator is used for token pasting or token concatenation
#define CONCATENATE(a, b) a ## b

#include <stdio.h>

#define UNIQUE_NAME(name, suffix) name ## _ ## suffix

int main() {
    int variable_foo = 42;
    int variable_bar = 10;

    int result = UNIQUE_NAME(variable, foo); // Combines variable and foo into variable_foo
    printf("Result: %d\n", result);

    result = UNIQUE_NAME(variable, bar); // Combines variable and bar into variable_bar
    printf("Result: %d\n", result);

    return 0;
}

4.11.3 Conditional Inclusion
-  refers to the process of including or excluding parts of the source code based on certain conditions during the preprocessing phase. 
- This is typically achieved using preprocessor directives, and it allows you to create code that is more versatile and adaptable for different scenarios.
- The most common preprocessor directives used for conditional inclusion are:
**#if, #elif, #else, and #endif: These directives are used to conditionally include or exclude code based on preprocessor-defined macros or constants. For example:

#define DEBUG 1

#if DEBUG
    // Code included when DEBUG is true
    printf("Debug mode is enabled.\n");
#else
    // Code included when DEBUG is false
    printf("Debug mode is disabled.\n");
#endif

Ch5 Pointers and Arrays
- a pointer is a variable that contains the address of a variable

5.1 Pointers and Addresses
- any byte can be a char, a pair of one byte cells can be treated as a short int
- four adjacent bytes form a long
- a pointer is a group of cells (often 2 or 4) that can hold an address
p = &c;
	- this assigns the address of c to the variable p, and p is said to point to C
- the & operator only applies to onjects in memory: variables and array elements
- it cannot be applied to expressions, constants, or register variables
- * is the inderection or dereferencing operator
	- when applied to a point, accesses the object the pointer points to

5.2 Pointers and Function arguments
- C passes arguments to functions by value
- pointer arguments enable a function to access and change objects in the function that called it 
- pointers pass by reference

5.3 Pointers and Arrays 
- there is a strong relationship between pointers and arrays
- any operation that can be achieved by array subscripting can also be done with pointers
- pointers are generally faster
- * is used to dereference a pointer (access the value pointed to by a pointer) or to define a pointer variable.
- & is used to obtain the address of a variable, effectively creating a pointer to that variable.

5.4 Address Arithmetic
- If p is a pointer to some lement of an array, then p++ increments p to point to the next element
- p+=i increments it to point i elements beyond where it currently does 
- rudimentary storage allocator
#include <stdio.h>
#include <stdlib.h>

#define MAX_MEMORY 1024 // Maximum memory size

typedef struct Block {
    size_t size;          // Size of the memory block
    struct Block *next;   // Pointer to the next block
} Block;

// Initial free memory block
Block *free_block = NULL;

// Function to initialize the memory allocator
void initialize_allocator() {
    if (free_block == NULL) {
        free_block = (Block *)malloc(MAX_MEMORY);
        free_block->size = MAX_MEMORY;
        free_block->next = NULL;
    }
}

// Function to allocate memory
void *allocate(size_t size) {
    if (size <= 0) {
        return NULL;
    }

    Block *current = free_block;
    Block *prev = NULL;

    while (current) {
        if (current->size >= size) {
            if (current->size > size) {
                Block *new_block = (Block *)((char *)current + size);
                new_block->size = current->size - size;
                new_block->next = current->next;
                if (prev) {
                    prev->next = new_block;
                } else {
                    free_block = new_block;
                }
            } else {
                if (prev) {
                    prev->next = current->next;
                } else {
                    free_block = current->next;
                }
            }

            return (void *)current;
        }
        prev = current;
        current = current->next;
    }

    return NULL; // Memory allocation failed
}

// Function to deallocate memory
void deallocate(void *ptr) {
    if (ptr) {
        Block *block = (Block *)ptr;
        block->next = free_block;
        free_block = block;
    }
}

// Function to print free memory blocks
void print_free_memory() {
    Block *current = free_block;
    while (current) {
        printf("Free block: size=%lu\n", current->size);
        current = current->next;
    }
}

int main() {
    initialize_allocator();

    int *int_ptr = (int *)allocate(sizeof(int));
    if (int_ptr) {
        *int_ptr = 42;
        printf("Allocated integer: %d\n", *int_ptr);
        deallocate(int_ptr);
    } else {
        printf("Memory allocation failed\n");
    }

    print_free_memory();

    return 0;
}

- in general a pointer can be initialized just as any other variable can
- C guarantees that zero is never a valid address for data
	- so, a return value of zero can be used to signal an abnormal event 
- pointers and integers are not interchangeable
	- zero is the only exception
		- the constant 0 can be assigned to a pointer, and a pointer may be compared with the constant 0
		- NULL is often used in place of 0
- pointers may be compared under certain circumstances
- any pointer can be meaningfully compared for equality or inequality with 0
- Pointer arithmetic is primarily used for iterating over arrays and other data structures

5.5 Character Pointers and Functions
- an array is terminated with '\0' so that programs can find the end

5.6 Pointer Arrays; Pointers to Pointers
- pointers are variables themselves, and can be stored in arrays just like other variables
- the sorting process has 3 steps:
	- read all the lines of input
	- sort them
	- print them in order
- the input routing has to collect and save the characters of each line and build an array of pointers to the lines
- it will have to count the number of input lines, because that info is needed for sorting and printing

5.7 Multi-dimensional Arrays
- C provides rectangular multi-dimensional arrays
- they are much less used than arrays of pointers
- syntax:
	daytab[i][j] [row][col]

5.8 Initialization of Pointer Arrays 
- you can initialize with specific values or:
- you can initialize with null pointers

5.9 Pointers vs. Multi-dimensional Arrays
- the advantage of the pointer array is that the rows of the array may be of different lengths

5.10 Command-line arguments
- when main is called, it is called with two arguments
- the first is the number of command line arguments the program was invoked with
- the second is a pointer to an array of character strings that contain the arguments, one per string
- we can manipulate the pointer rather than index the array

5.11 Pointers to Functions
- in C, a function itself is not a variable
- it is possible to define pointers to functions

5.12 Complicated Declarations
- one good way to synthesize declarations is in small steps with typedef
- look @ page 122
- A "direct declarator" or "direct-dcl" in C refers to the part of a declaration that directly specifies the name and type of an identifier. 
- In C's grammar for declarations, a declarator is composed of a pointer part and a direct declarator part. 
- The direct declarator specifies the name of the declared entity and its type. 
- It may also include additional information such as array dimensions, function parameters, and other qualifiers.
- general syntax:
	type-specifier declarator;
- Direct declarators can become more complex when combined with pointer declarators and additional qualifiers. 
- Understanding declarators is crucial when working with C declarations and understanding the structure of variables, arrays, and functions in C programs.

Ch6 Structures
- a structure is a collection of one or more variables
    - can be of different types
    - theyre grouped together under a signle name for convenient handling
- Structs help organize complicated data (esp in large programs)
    - they help permit a group of related variables to be treated as a unit instead of separately
- automatic structures and arrays can be initialized

6.1 Basic Structures
- structure tag is the name given to the struct
- variables named in structs are called members
- the same meber names can occur in different structs
    - usally better used with closely related objects
- . connects the struct name and the member name

#include <stdio.h>
#include <string.h>

// Define a struct for a payroll record
struct PayrollRecord {
    int employeeID;
    char firstName[50];
    char lastName[50];
    float hourlyRate;
    int hoursWorked;
    float totalPay;
};

int main() {
    // Create a payroll record
    struct PayrollRecord employee;

    // Fill in the details
    employee.employeeID = 101;
    strcpy(employee.firstName, "John");
    strcpy(employee.lastName, "Doe");
    employee.hourlyRate = 15.50;
    employee.hoursWorked = 40;
    employee.totalPay = employee.hourlyRate * employee.hoursWorked;

    // Display the payroll record
    printf("Employee ID: %d\n", employee.employeeID);
    printf("Name: %s %s\n", employee.firstName, employee.lastName);
    printf("Hourly Rate: %.2f\n", employee.hourlyRate);
    printf("Hours Worked: %d\n", employee.hoursWorked);
    printf("Total Pay: %.2f\n", employee.totalPay);

    return 0;
}

6.2 Structures and Functions
- the only legal operations on a struct are copying it or assigning to it as a unite
    - taking its address with &, and accessing its members (i.e. employeeID)
- if a large struct is passed to a function, it is more efficient to pass a pointer than to copy the whole struct
- pointers to structs are used a token
    - if a p is a pointer to a struct, then
    p->member-of-struct

6.3 Arrays of Structures
- In this example, we define a struct Employee to represent an employee record. 
- We create an array of structures called employees to store three employee records. 
- Then, we fill in the details for each employee by accessing the elements of the array of structures and finally display the employee records.
- This allows you to efficiently store and manage multiple records of the same structure type, 
    making it useful for tasks such as maintaining employee databases or handling data with a similar structure.

#include <stdio.h>
#include <string.h>

// Define a struct for an employee record
struct Employee {
    int employeeID;
    char firstName[50];
    char lastName[50];
    float salary;
};

int main() {
    // Create an array of structures to store employee records
    struct Employee employees[3];

    // Fill in the details for each employee
    employees[0].employeeID = 101;
    strcpy(employees[0].firstName, "John");
    strcpy(employees[0].lastName, "Doe");
    employees[0].salary = 55000.0;

    employees[1].employeeID = 102;
    strcpy(employees[1].firstName, "Alice");
    strcpy(employees[1].lastName, "Smith");
    employees[1].salary = 60000.0;

    employees[2].employeeID = 103;
    strcpy(employees[2].firstName, "Bob");
    strcpy(employees[2].lastName, "Johnson");
    employees[2].salary = 52000.0;

    // Display the employee records
    printf("Employee Records:\n");
    for (int i = 0; i < 3; i++) {
        printf("Employee ID: %d\n", employees[i].employeeID);
        printf("Name: %s %s\n", employees[i].firstName, employees[i].lastName);
        printf("Salary: %.2f\n\n", employees[i].salary);
    }

    return 0;
}

6.4 Pointers to Structures
- Pointers to structures in C are used to work with complex data structures efficiently. 
- They allow you to access and manipulate the members (fields) of a structure without having to copy the entire structure. 
- This can be particularly useful when you're dealing with large data structure
- you cannot add two pointers
- subtraction is legal
- you have to adjust the algorithm to make sure that it does not general an illegal pointer or
    - attempt to access an element outside the array
- pointer arithmetic that involves the first element beyond the end of an array will work correctly
- the size of a structure is not necessarily the sum of the sizes of its members 
- the sizeof operator will return proper values
- ex.
    - if a char is one byte and an int four bytes, the struct might requires eight bytes, not five

6.5 Self-Referential Structures
- keeping a set a words will be sorted at all times by placing each word into its proper position in the order as it arrives
- Binary Trees:
    - the tree contains one node per distinct word
    - each word contains:
        - a pointer to the text of the word
        - a count of the number of occurrences
        - a pointer to the left child node
        - a pointer to the right child node
    - no node can contain more than two children
    - it might only have zero or one
    - how nodes are maintained:
        - any node the left subtree contains only words that are lexicographically less than the word at the node,
        - and the right subtree contains only words that are greater
    - ex. the tree for the sentence "now is the time for all good men to come to the aid of their party 
        - as built by inserting each word as it is encountered:
              now
            /     \ 
          is      the 
        /  \      |   \
       for  men   of   time 
      /  \        |    /   \
    all  good    party their to
    / \
  aid  come   

- to find out whether a new word is already in the tree, start at the root and compare the new work to the word stored at that node
- if they match, the question is answered affirmatively
- if the new word is less than the tree word, continue searching at the left child, otherwise at the right child
- if there is no child in the required direction, the new word is not in the tree, and the empty slot is the proper place to add the new word
- the process is recursive since the search from any node uses a search from one of its children
- eventually the word either matches something already in the tree (in which case the count is incremented)
    - or a null pointer is encountered, indicating that a node must be created and added to the tree
    - if a new node is created, addtree returns a pointer to it, which is installed in the parent node 

In a binary search tree, the values in the left subtree are smaller than the value in the parent node, and the values in the right subtree are greater. 
When inserting a new value, you compare it with the current node's value and decide whether to place it in the left or right subtree based on this comparison. 
This ensures that the tree is organized for efficient searching.
Example:
If the parent node contains the value 10, 
a smaller value like 5 would be placed in the left subtree, 
and a larger value like 15 would be placed in the right subtree.

- integers often must be located at even addresses
- malloc function:
    - memory allocation

6.6 Table Lookup
- Table lookup in C is a technique used to search for a value or retrieve data from a predefined table or data structure. 
    -This table is often an array, and the idea is to find an item in the table based on a key or index
    - create a table
    - search for an item
    - error handling

6.7 typedef
- typedef is used for creating new data type names
    - ex typedef int Length;
        - makes the name Length a synonym for Length
        - Length can now be used in the same way as the type int 
    - ex typedef char *String
        - String is now a synonym for character pointer
        - can now be used in declarations and casts 
- typedef does not create a new type,
    - it adds a new name for some existing type
- variables declared in this way have the same properties as the variables theyre "replacing"
- typedef is kind of like #define 
- Two main reasons to use typedef:
    - parameterize a program against portability problems
    - provide better documentation of a program
        - Treeptr may be easier to understand than one declared only as a pointer to a complicated structure 

6.8 Unions
- a union is a variable that may hold (at different times) objects of different types and sizes
    - with the compiler keeping track of size and alignment requirements
- they provide a way to manipulate different kinds of data in a single area of storage
    - without embedding any machine-dependent info in the program 
union u+tag {
    int ival;
    float fval;
    char *sval;
} u;

- the variable u will be large enough to hold the largest of the three data types
- any one of these types can be assigned to u and then used in expressions
    - so long as the usage is consistent
- it is the programmers responsibility to keep track of which type is currently stored in a union
- the results are implementation dependent if something is stored as one type and extracted as another
    - union-name.member 
    - union-pointer->member
- unions may occur within structures and arrays and vice versa
- notation for accessing a member of a union in a struct is identical to that for nested structs
- a union may only be initialized with a value of the type of its first member

6.9 Bit-fields
*** Look this over in the book! ***

