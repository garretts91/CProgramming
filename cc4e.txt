cc4e

Ch0

- Heap refers to memory that C manages on our behalf when we need to borrow memory and give it back later
- its up to the programmer to give dynamic memory back
- Making good use of dynamic memory allocation
- it is independent of any particular machine architecture
- c provides pointers and the ability to do address arithmetic

Ch1

- all variables must be declared before use
- a declaration consists of a type, and a list of variables which have that type
- char - character, single byte
- short - short integer
- long - long integer
- double - double-precision floating point
- the size of these objects are machine-dependent
- it is wise to write floating point constants with explicit decimal points even when they have integral values
- scanf is like printf except it reads input instead of writing output
- for and while loops are indeterminate
- Symbolic Constants:
	- #define LOWER
	- #define UPPER
- symbolic names are written in uppercase so they can be distinguished from lower case variable names
- %ld is a long integer
- double is a double length float
- Arrays
- Scope

Ch2

2.1 Variable names:
- there are some restrictions on variable and symbolic constant names
- reserved variables
- choose variable names that make sense

2.2 Data Types and Sizes:
- char		- single byte, one character
- int		- integer
	- qualifiers:
		- short int x;
		- long int y;
		- unsigned int z;
		- int can be omitted in these cases
- float 	- single precision floating point
- double	- double precision floating point
- precision depends on the machine
- check the table in 2-2?

2.3 Constants:
- scientific notation for floats is legal
- a leading 0 on an int represents an octal
- a leading 0x represents hex
- they both can be followed by L to make them a long
- character constant is a single char written in single quotes
- constant expression is an expression that involves only constants
- quotes in a string are used as a delimiter
(check Programming Truncation Explanation in gpt)

2.4 Declarations:
- All variables must be declared before use
- a declaration specifies a type
	- int lower, upper, step;
	- char c, line[1000]
- variables can be initialized in their declaration:
	- char backslash = '\\';
	int i = 0;
	
2.5 Arithmetic Operators
- + - * / %
- % cannot be applied to float or double

2.6 Relational and Logic Operators
- Relational Operators:
	- > >= < <=
	- they all have the same precedence
- equality operators:
	- == !=
- logical connectives:
	- && ||
	- the precedence of && is higher than ||
- unary negation operator ! 
	- converts true to false and false to true
	
2.7 Type Conversions
- chars and ints can be mixed in arithmetic
- check out atoi
- check out gets function
- check out binary operators
- check out the implicit arithmetic conversions
- all floating point arithmetic in C is done in double precision
- conversions take place across assignments
	- int i;
	- char c;
	- i = c;
	- c = i;

2.8 Increment and Decrement Operators
- ++ --

2.9 Bitwise Logical Operators
- & bitwise AND
- | bitwise inclusive OR
- ^ bitwise exclusive OR
- << left shift
- >> right shift
- ~ one's compliment (unary)
- check getbits operator
- declaring the argument x to be unsigned ensures that when it is right shifted, vacated bits will be filled with zeroes and not sign bits (regardless of the machine it is ran on)
- bitwise operators play a role in encryption, decryption, and checksum calculations
****- look @ exercise 2-5? Modify getbits to number bits from left to right

2.10 Assignment Operators and Expressions
- i += 2
- check bitcount
****- look at the code in this section

2.11 Conditional Expressions
- if (a > b)
	z = a;
	else
	z = b;
- e1 ? e2 : e3
- ternary operator

2.12 Precedence and Order of Evaluation
- check the table!
- * indirection
- & address of
- check side effect operators
- writing code that depends on order of evaluation is a bad programming practice in any language!

Ch3 Control Flow


3.1 Statements and Blocks
- an expression becomes a statement when it is followed by a semicolon
	- x = 0;
	- ++i;
- the semicolon is a statement terminator
- {} are used to group statements and Declarations into blocks or compound statements
- variables can be declared inside any blocks

3.2 if-else
- if (expression)
	statement1
	else
	statement2
- else can be optional
 if (n > 0)
	if (a > b)
	z = a;
 else 
	z = b;
- this else goes with the inner if
- if that isnt what is wanted then you have to use braces to force proper association
if (n > 0){
	if (a > b)
		z = a;
} else 
	z = b;

3.3 else-if
if (expression)
	statement 
else if (expression)
	statement
else if (expression)
	statement 
else
	statement
(this last else is good for error checking)
- if expressions are evaluated in order
- Binary search function
- this decides if a particular value x occurs in the sorted array v. 
- the elements of v must be in increasing order
- the function returns the position (a number between 0 and n-1) if x occurs in v, and -1 if not
- binary search first compares the input value x to the middle element of the array v
- if x is less than the middle value, searching focuses on the lower half of the table, otherwise on the upper half
- in either case, the next step is to compare x to the middle element of the selected half
- this process of dividing the range in two continues until the value is found or the range is empty
/* binsearch: find x in v v[0] <= v[1] <= ... <= v[n-1] */

int binsearch (int x, int[v], int n)
{
	int low, high, mid;

	low = 0;
	high = n - 1;
	while (low <= high){
		mid = (low+high) / 2;
		if (x < v[mid])
			high = mid - 1;
		else if (x > v[mid])
			low = mid + 1;
		else // found match 
			return mid;
	}
	return -1; // no match
}

- the fundamental decision is whether x is less than, greater than, or equal to
	- the middle element v[mid] at each step;
		- this is perfect for an else-if
- look @ exercise 3-1

3.4 Switch
- Switch statments are a multi-way decision that tests whether an expression matches one 
	- of a number of constant integer values, and branches accordingly

switch (expression){
	case const-expr: statements
	case const-expr: statements
	default: statements
}

- each case is labeled by one or more integer valued constants or constant expressions
- all case expressions must be different
- default is executed when no other cases are satisfied
- default is optional
- cases and default can be in any order

#include <stdio.h>

int main() //count digits, white space, others
{
    int c, i, nwhite, nother, ndigit[10];

    nwhite = nother = 0;
    for (i = 0; i < 10; i++)
        ndigit[i] = 0;
    while ((c = getchar()) != EOF ){
        switch (c) {
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                ndigit[c-'0']++;
                break;
            case ' ':
            case '\n':
            case '\t':
                nwhite++;
                break;
            default:
                nother++;
                break;
        }
    }
    printf("\ndigits = ");
    for (i= 0; i < 10; i++)
        printf("%d", ndigit[i]);
    printf(", white spaces = %d, other = %d\n", nwhite, nother);
    return 0;
}

- break statement immediately ends the switch
- break and return are the most common ways to exit a switch
- you can use break in loops
- look @ exercise 3-2

3.5 Loops - While and for
while (expression)
	statement

for (expr1; expr2; expr3)
	statement

is the same as:

expr1;
while (expr2){
	statement
	expr3;
}

- for loops are preferable when there is an initialization and you need to increment
for (i = 0; i < 10; i++)
- for loops are not restricted to arithemetic progressions
- atoi for converting a string to a numeric equivalent
- the structure of this program reflects the form of the input:
skip white space, if any
get sign, if any
get integer part and convert it

#include <ctype.h>

// atoi convert s to integer; v2

int atoi(char s[])
{
    int i, n, sign;

    for (i = 0; isspace(s[i]); i++) //skip white space
        ;
    sign = (s[i] == '-') ? -1 : 1;
    if (s[i] == '+' || s[i] == '-') //skip sign
        i++;
    for (n = 0; isdigit(s[i]); i++)
        n = 10 * n + (s[i] - '0');
        return sign * n;
}

- the standard library provides a more elaborate function strtol
	- conversion from string to long int

- look up shell sort for C
- a pair of expressions separated by a comma is evaluated left to right
- the type and value of the result are the type and value of the right operand
- you can do this to process two indices in parallel

//reverse string s in place
#include <string.h>

void reverse(char s[])
{
	int c, i, j;

	for (i = 0, j = strlen(s)-1; i < j; i++, j--){
		c = s[i];
		s[i] = s[j];
		s[j] = c;
	}
}

- comma operators should be used sparingly
- a comma expression might be appropriate for the exchange of elements in reverse

3.6 Loops - Do-while

- do while tests at the bottom after making each pass through the loop body
do
	statement
while (expression);

- the statement is executed, then expression is evaluated
- can be useful in some cases like itoa (# to string)

// itoa: convert n to characters in s
void itoa(int n, char s[])
{
	int i, sign;

	if ((sign = n) < 0) //record sign
		n = -n; // make n positive
	i = 0;
	do { 	// generate digits in reverse order
		s[i++] = n % 10 + '0'; // get next digit
	} while ((n /= 10) > 0); //delete it
	if (sign < 0)
	s[i++] = '-';
	s[i] = '\0';
	reverse(s);
}

3.7 Break and Continue 
- break provides an early exit from a loop

// trim: remove trailing blanks, tabs, newlines
int trim(char s[])
{
	int n;

	for (n = strlen(s)-1; n >= 0; n--)
		if (s[n] != ' ' && s[n] != '\t' && s[n] != '\n')
		break;
	s[n+1] = '\0';
	return n;
}
- strlen returns the length of a string
- the for loop starts at the end and iterates backwards
- the loop breaks when one is found
- always verify for correct behavior
- the continue statement only applies to loops, never switch
- this fragment processes only non-negative elements in the array, a; negative values are skipped

	for (i = 0; i < n; i++){
		if (a[i] < 0) //skip negative elements
			contine;
			... // do positive elements
	}

3.8 GOTO and Labels
- Formally, goto is never necessary
	for ()
		for (){
			...
			if (disaster)
				goto error;
		}
error:
	clean up the mess 

- this organization is handy if the error-handling code in non-trivial
	- and if errors can occur in multiple places

Ch4 Functions and Program structure

- functions break large computing tasks into smaller ones
- great for creating templates
- C programs generally consist of a lot of small functions
- syntax of function definitions change, so declarations and definitions match
	- this makes it easy for the compiler to detect more errors

4.1 Basics of Functions

- remember C arrays begin at index 0
- strindex function to determine occurrence of a pattern:
#include <stdio.h>
#define MAXLINE 1000 // max input line length

int getline(char line[], int max);
int strindex(char source[], char searchfor[]);

char pattern[] = "ould"; //pattern to search for 

// find all lines matching the pattern:
int main()
{
    char line [MAXLINE];
    int found = 0;

    while(getline(line, MAXLINE) > 0)
        if (strindex(line, pattern) >= 0){
            printf("%s", line);
            found++;
        }
    return found;
}

// getline: get line into s, return length
int getline(char s[], int lim)
{
    int c, i;

    i = 0;
    while(--lim > 0 && (c=getchar()) != EOF && c != '\n')
        s[i++] = c;
    if (c == '\n')
        s[i++] = c;
    s[i] = '\0';
    return i;
}

//strindex: return index of t in s, -1 if none
int strindex(char s[], char t[])
{
    int i, j, k;

    for (i = 0; s[i] != '\0'; i++){
        for (j = i, k = 0; t[k] != '\0' && s[j] == t[k]; j++, k++);
        if (k > 0 && t[k] == '\0')
            return i;
    }
    return -1;
}

- Each function definiton has the form:
	- return-type function-name(argument declarations)
	  {
			declarations and statements
	  }
- various parts may be absent; a minimal function is 
	- dummy () {}
	- this is a do nothing function
	- can be useful as a placeholder
- a program is just a set of definitions of variables and functions
- communication between the functions is by arguments and values returned by the functions
	- and through external variables
- functions can occur in any order in the source file
	- the source program can be split into multiple files (so long as no function is split)
- return statement returns a value from the called function to its caller
	- "return expression";
	- the expression will be converted to the return type of the function if necessary
- the calling function is free to ignore the returned value
- if a function fails to return a value, its value is garbage
- multiple source files can be called upon using cc from terminal
	- ex. cc main.c getline.c strindex.C
	- it compiles the 3 files, and results in 3 .o files (object files)

4.2 Functions Returning Non-Integers
- atoi and atof
	- converts strings to numerical values
- atoi (ascii to int)
	- a function used to convert a string representing an integer (in ASCII format) into an actual integer data type. 
	- It takes a string as its argument and returns an integer
	- ex. int atoi(const char *str);
- atof (ascii to floatint-point)
	- a function used to convert a string representing a floating-point number (in ASCII format) into a floating-point data type, typically a double
	- ex. double atof(const char *str);
- these are useful for parsing and converting user input or data read from files where numbers are represented as strings

#include <ctype.h>
double my_atof(char s[])
{
    double val, power;
    int i, sign;
    
    for (i = 0; isspace(s[i]); i++); //skip white space
    sign = (s[i] == '-') ? -1 : 1;
    if (s[i] == '+' || s[i] == '-')
    i++;
    for (val = 0.0; isdigit(s[i]); i++)
        val = 10.0 * val + (s[i] - '0');
    if (s[i] == '.')
        i++;
    for (power = 1.0; isdigit(s[i]); i++){
        val = 10.0 * val + (s[i] - '0');
        power *= 10.0;
    }
    return sign * val / power;
}

- double sum, atof(char []);
	- says that sum is a double and that atof is a function that takes one char argument
- atof must be declared and defined consistently
- if atof and the call to it in main have incosistent types, you will get an error
- this can get tricky in separate compilation
- if the function takes arguments, declare them; 
	- if it takes no arguments, use void
// atoi: convert string s to int using atof
int atoi(char[s])
{
	double atof(char s[]);

	return (int) atof(s);
}

4.3 External variables
- A C program consists of a set of external objects, which are either variables or functions
- external variables are defined outside of any function
	- can be available to many Functions
- "external linkage"
	- refers to the property of a variable or function that allows it to be accessed or used from different source files (translation units) in a program. 
	- Variables and functions with external linkage have a global scope, meaning they can be used across multiple files, not just the file in which they are declared.
- apply with caution!
- pushing and popping operators and operands:
while (next operator or operand is not EOF indicator)
	if (number)
		push it
	else if (operator)
		pop operands
		do operation
		push result
	else if (newline)
		pop and print top of stack
	else 
		error

#include <stdio.h>
#include <stdlib.h> //for atof

#define MAXOP 100 //max size of operand or operator
#define NUMBER '0' //signal that a number was found

int getop(char []);
void push(double);
double pop(void);

// reverse polish calculator
int main()
{
    int type;
    double op2;
    char s[MAXOP];

    while ((type = getop(s)) != EOF){
        switch (type) {
        case NUMBER:
            push(atof(s));
            break;
        case '+':
            push(pop() + pop());
            break;
        case '*':
            push(pop() * pop());
            break;
        case '-':
            op2 = pop();
            push(pop() - op2);
            break;
        case '/':
            op2 = pop();
            if (op2 != 0.0)
                push(pop() / op2);
            else printf("error: zero divisor\n");
            break;
        case '\n':
            printf("\t%.8g\n", pop());
            break;
        default:
            printf("error: unknown command %s\n", s);
            break;           
        }
    }
    return 0;
}

- variable is external if it is defined outside of any function
- getop fetches the next operator or operand

4.4 Scope Rules
- extern declatation
- You can declare a global variable as extern in a source file to indicate that it's defined in another source file. 
	- This allows you to use the variable in the current source file without redefining it.
- there must only be one definition of an external variable among all the files that make up the source Program
	- other files may contain extern declatations to access it
- "file 1":
	extern int sp;
	extern double val[];

	void push(double f) {...}
	double pop(void) {...}
- "file2":
	int sp = 0;
	double val[MAXVAL];
- the extern declaration in file lie ahead of and outside the function definition,
	- they apply to all functions;

4.5 Header Files 
- Header files in C are used to declare the interfaces, prototypes, and declarations for functions, variables, and types that are used across multiple source files in a program. 
	- They play a crucial role in modularizing and organizing your code, promoting code reusability, and reducing the likelihood of errors. 
- Declaration of Functions and Variables
	- Header files typically contain the declarations (function prototypes) of functions and variables that are meant to be used across multiple source files.
- Code Reusability
	- Header files allow you to reuse code across multiple source files. By including a header file, you can access functions and variables defined in one source file from another.
	- This promotes code modularity and makes it easier to maintain and update your codebase.
- Avoiding Code Duplication
	- By placing common function prototypes and declarations in header files, you avoid duplicating the same declarations in multiple source files. 
	- This reduces the risk of inconsistencies and makes it easier to update the code.
- Encapsulation
	- Header files can also be used to encapsulate the implementation details of a module (source file).
	- You can hide the internal implementation details and only expose the necessary parts through the header file.
- Standard Library Headers
	- C also provides a set of standard library header files, such as <stdio.h> for input and output functions and <stdlib.h> for memory allocation functions. 
	- These headers contain prototypes and declarations for standard library functions.
- Inclusion using #include
	- To use a header file in a source file, you include it using the #include preprocessor directive. 
	- For example, #include "mylibrary.h" brings in the declarations from "mylibrary.h."

4.6 Static variables
- the static declaration limits the scope of that object to the rest of the source file being compiled
- static storage is specified by prefixing the normal declaration with the word Static
- if a function is declared static, its name is invisible outside of the file in which it is declared
- static can also be applied to internal variables
	- are local to a particular function
	- internal static variables provide private, permanent storage within a single function

4.7 Register Variables
- a register declaration advises the compiler that the variable in question will be heavily used
- the register declaration can only be applied to automatic variables and to the formal parameters of a function
- only certain types are allowed
- theyre usually used for faster access
- it isnt used much these days

4.8 Block structure
- Block structures are fundamental for organizing code, managing scope, and controlling program flow in C. 
- They help ensure that variables have well-defined lifetimes and scopes and are a key part of creating modular and maintainable C programs.

4.9 Initialization
- for external and static variables, the initializer must be a constant expression
- refers to the process of giving a variable its initial value when it is declared
- Initialization is an important aspect of C programming because it ensures that variables start with a known and often meaningful value
- when the size of an array is omitted, the compuler will compute the length by counting the initializers \
- it is an error to have too many initializers

4.10 Recursion
- In C, a function may call itself either directly or indirectly
#include <stdio.h>

// Recursive function to calculate the factorial of a number
unsigned long long factorial(int n) {
    if (n == 0) {
        return 1; // Base case: 0! = 1
    } else {
        return n * factorial(n - 1); // Recursive case: n! = n * (n-1)!
    }
}

int main() {
    int num = 52;
    unsigned long long result = factorial(num);
    printf("Factorial of %d = %llu\n", num, result);
    return 0;
}

- the standard library includes a version of qsort that can sort objects of any type
- recursive code is compact and often easier to write and understand than the non-recursive equivalent

4.11 The C Preprocessor 
- used for #include and #defined
	- #include "filename"
		- if the filename is quoted, searching begins where the source program was found
	- #include <filename>
		- searching follows an implementation defined rule to find the file
- #include is the preferred way to tie the declarations together for a large program

4.11.2 Macro Substitution
- A definition has the form
	#define name replacement text
- Macro substitution is a powerful tool in C for creating reusable and easy-to-maintain code. 
- Macros can be used to define constants, simple calculations, and even short code snippets that are used frequently. 
- However, it's important to use macros carefully and follow best practices to avoid potential pitfalls, 
	- such as unexpected behavior due to operator precedence or side effects in macro expressions.
- the ## operator is used for token pasting or token concatenation
#define CONCATENATE(a, b) a ## b

#include <stdio.h>

#define UNIQUE_NAME(name, suffix) name ## _ ## suffix

int main() {
    int variable_foo = 42;
    int variable_bar = 10;

    int result = UNIQUE_NAME(variable, foo); // Combines variable and foo into variable_foo
    printf("Result: %d\n", result);

    result = UNIQUE_NAME(variable, bar); // Combines variable and bar into variable_bar
    printf("Result: %d\n", result);

    return 0;
}

4.11.3 Conditional Inclusion
-  refers to the process of including or excluding parts of the source code based on certain conditions during the preprocessing phase. 
- This is typically achieved using preprocessor directives, and it allows you to create code that is more versatile and adaptable for different scenarios.
- The most common preprocessor directives used for conditional inclusion are:
**#if, #elif, #else, and #endif: These directives are used to conditionally include or exclude code based on preprocessor-defined macros or constants. For example:

#define DEBUG 1

#if DEBUG
    // Code included when DEBUG is true
    printf("Debug mode is enabled.\n");
#else
    // Code included when DEBUG is false
    printf("Debug mode is disabled.\n");
#endif


