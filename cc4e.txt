cc4e

Ch0

- Heap refers to memory that C manages on our behalf when we need to borrow memory and give it back later
- its up to the programmer to give dynamic memory back
- Making good use of dynamic memory allocation
- it is independent of any particular machine architecture
- c provides pointers and the ability to do address arithmetic

Ch1

- all variables must be declared before use
- a declaration consists of a type, and a list of variables which have that type
- char - character, single byte
- short - short integer
- long - long integer
- double - double-precision floating point
- the size of these objects are machine-dependent
- it is wise to write floating point constants with explicit decimal points even when they have integral values
- scanf is like printf except it reads input instead of writing output
- for and while loops are indeterminate
- Symbolic Constants:
	- #define LOWER
	- #define UPPER
- symbolic names are written in uppercase so they can be distinguished from lower case variable names
- %ld is a long integer
- double is a double length float
- Arrays
- Scope

Ch2

2.1 Variable names:
- there are some restrictions on variable and symbolic constant names
- reserved variables
- choose variable names that make sense

2.2 Data Types and Sizes:
- char		- single byte, one character
- int		- integer
	- qualifiers:
		- short int x;
		- long int y;
		- unsigned int z;
		- int can be omitted in these cases
- float 	- single precision floating point
- double	- double precision floating point
- precision depends on the machine
- check the table in 2-2?

2.3 Constants:
- scientific notation for floats is legal
- a leading 0 on an int represents an octal
- a leading 0x represents hex
- they both can be followed by L to make them a long
- character constant is a single char written in single quotes
- constant expression is an expression that involves only constants
- quotes in a string are used as a delimiter
(check Programming Truncation Explanation in gpt)

2.4 Declarations:
- All variables must be declared before use
- a declaration specifies a type
	- int lower, upper, step;
	- char c, line[1000]
- variables can be initialized in their declaration:
	- char backslash = '\\';
	int i = 0;
	
2.5 Arithmetic Operators
- + - * / %
- % cannot be applied to float or double

2.6 Relational and Logic Operators
- Relational Operators:
	- > >= < <=
	- they all have the same precedence
- equality operators:
	- == !=
- logical connectives:
	- && ||
	- the precedence of && is higher than ||
- unary negation operator ! 
	- converts true to false and false to true
	
2.7 Type Conversions
- chars and ints can be mixed in arithmetic
- check out atoi
- check out gets function
- check out binary operators
- check out the implicit arithmetic conversions
- all floating point arithmetic in C is done in double precision
- conversions take place across assignments
	- int i;
	- char c;
	- i = c;
	- c = i;

2.8 Increment and Decrement Operators
- ++ --

2.9 Bitwise Logical Operators
- & bitwise AND
- | bitwise inclusive OR
- ^ bitwise exclusive OR
- << left shift
- >> right shift
- ~ one's compliment (unary)
- check getbits operator
- declaring the argument x to be unsigned ensures that when it is right shifted, vacated bits will be filled with zeroes and not sign bits (regardless of the machine it is ran on)
- bitwise operators play a role in encryption, decryption, and checksum calculations
****- look @ exercise 2-5? Modify getbits to number bits from left to right

2.10 Assignment Operators and Expressions
- i += 2
- check bitcount
****- look at the code in this section

2.11 Conditional Expressions
- if (a > b)
	z = a;
	else
	z = b;
- e1 ? e2 : e3
- ternary operator

2.12 Precedence and Order of Evaluation
- check the table!
- * indirection
- & address of
- check side effect operators
- writing code that depends on order of evaluation is a bad programming practice in any language!

Ch3 Control Flow


3.1 Statements and Blocks
- an expression becomes a statement when it is followed by a semicolon
	- x = 0;
	- ++i;
- the semicolon is a statement terminator
- {} are used to group statements and Declarations into blocks or compound statements
- variables can be declared inside any blocks

3.2 if-else
- if (expression)
	statement1
	else
	statement2
- else can be optional
 if (n > 0)
	if (a > b)
	z = a;
 else 
	z = b;
- this else goes with the inner if
- if that isnt what is wanted then you have to use braces to force proper association
if (n > 0){
	if (a > b)
		z = a;
} else 
	z = b;

3.3 else-if
if (expression)
	statement 
else if (expression)
	statement
else if (expression)
	statement 
else
	statement
(this last else is good for error checking)
- if expressions are evaluated in order
- Binary search function
- this decides if a particular value x occurs in the sorted array v. 
- the elements of v must be in increasing order
- the function returns the position (a number between 0 and n-1) if x occurs in v, and -1 if not
- binary search first compares the input value x to the middle element of the array v
- if x is less than the middle value, searching focuses on the lower half of the table, otherwise on the upper half
- in either case, the next step is to compare x to the middle element of the selected half
- this process of dividing the range in two continues until the value is found or the range is empty
/* binsearch: find x in v v[0] <= v[1] <= ... <= v[n-1] */

int binsearch (int x, int[v], int n)
{
	int low, high, mid;

	low = 0;
	high = n - 1;
	while (low <= high){
		mid = (low+high) / 2;
		if (x < v[mid])
			high = mid - 1;
		else if (x > v[mid])
			low = mid + 1;
		else // found match 
			return mid;
	}
	return -1; // no match
}

- the fundamental decision is whether x is less than, greater than, or equal to
	- the middle element v[mid] at each step;
		- this is perfect for an else-if
- look @ exercise 3-1

3.4 Switch
- Switch statments are a multi-way decision that tests whether an expression matches one 
	- of a number of constant integer values, and branches accordingly

switch (expression){
	case const-expr: statements
	case const-expr: statements
	default: statements
}

- each case is labeled by one or more integer valued constants or constant expressions
- all case expressions must be different
- default is executed when no other cases are satisfied
- default is optional
- cases and default can be in any order

#include <stdio.h>

int main() //count digits, white space, others
{
    int c, i, nwhite, nother, ndigit[10];

    nwhite = nother = 0;
    for (i = 0; i < 10; i++)
        ndigit[i] = 0;
    while ((c = getchar()) != EOF ){
        switch (c) {
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                ndigit[c-'0']++;
                break;
            case ' ':
            case '\n':
            case '\t':
                nwhite++;
                break;
            default:
                nother++;
                break;
        }
    }
    printf("\ndigits = ");
    for (i= 0; i < 10; i++)
        printf("%d", ndigit[i]);
    printf(", white spaces = %d, other = %d\n", nwhite, nother);
    return 0;
}

- break statement immediately ends the switch
- break and return are the most common ways to exit a switch
- you can use break in loops
- look @ exercise 3-2

3.5 Loops - While and for
while (expression)
	statement

for (expr1; expr2; expr3)
	statement

is the same as:

expr1;
while (expr2){
	statement
	expr3;
}

- for loops are preferable when there is an initialization and you need to increment
for (i = 0; i < 10; i++)
- for loops are not restricted to arithemetic progressions
- atoi for converting a string to a numeric equivalent
- the structure of this program reflects the form of the input:
skip white space, if any
get sign, if any
get integer part and convert it

#include <ctype.h>

// atoi convert s to integer; v2

int atoi(char s[])
{
    int i, n, sign;

    for (i = 0; isspace(s[i]); i++) //skip white space
        ;
    sign = (s[i] == '-') ? -1 : 1;
    if (s[i] == '+' || s[i] == '-') //skip sign
        i++;
    for (n = 0; isdigit(s[i]); i++)
        n = 10 * n + (s[i] - '0');
        return sign * n;
}

- the standard library provides a more elaborate function strtol
	- conversion from string to long int

- look up shell sort for C
- a pair of expressions separated by a comma is evaluated left to right
- the type and value of the result are the type and value of the right operand
- you can do this to process two indices in parallel

//reverse string s in place
#include <string.h>

void reverse(char s[])
{
	int c, i, j;

	for (i = 0, j = strlen(s)-1; i < j; i++, j--){
		c = s[i];
		s[i] = s[j];
		s[j] = c;
	}
}

- comma operators should be used sparingly
- a comma expression might be appropriate for the exchange of elements in reverse

3.6 Loops - Do-while

- do while tests at the bottom after making each pass through the loop body
do
	statement
while (expression);

- the statement is executed, then expression is evaluated
- can be useful in some cases like itoa (# to string)

// itoa: convert n to characters in s
void itoa(int n, char s[])
{
	int i, sign;

	if ((sign = n) < 0) //record sign
		n = -n; // make n positive
	i = 0;
	do { 	// generate digits in reverse order
		s[i++] = n % 10 + '0'; // get next digit
	} while ((n /= 10) > 0); //delete it
	if (sign < 0)
	s[i++] = '-';
	s[i] = '\0';
	reverse(s);
}

3.7 Break and Continue 
- break provides an early exit from a loop

// trim: remove trailing blanks, tabs, newlines
int trim(char s[])
{
	int n;

	for (n = strlen(s)-1; n >= 0; n--)
		if (s[n] != ' ' && s[n] != '\t' && s[n] != '\n')
		break;
	s[n+1] = '\0';
	return n;
}
- strlen returns the length of a string
- the for loop starts at the end and iterates backwards
- the loop breaks when one is found
- always verify for correct behavior
- the continue statement only applies to loops, never switch
- this fragment processes only non-negative elements in the array, a; negative values are skipped

	for (i = 0; i < n; i++){
		if (a[i] < 0) //skip negative elements
			contine;
			... // do positive elements
	}

3.8 GOTO and Labels
- Formally, goto is never necessary
	for ()
		for (){
			...
			if (disaster)
				goto error;
		}
error:
	clean up the mess 

- this organization is handy if the error-handling code in non-trivial
	- and if errors can occur in multiple places

Ch4 Functions and Program structure

- functions break large computing tasks into smaller ones
- great for creating templates
- C programs generally consist of a lot of small functions
- syntax of function definitions change, so declarations and definitions match
	- this makes it easy for the compiler to detect more errors

4.1 Basics of Functions

- remember C arrays begin at index 0
- strindex function to determine occurrence of a pattern:
#include <stdio.h>
#define MAXLINE 1000 // max input line length

int getline(char line[], int max);
int strindex(char source[], char searchfor[]);

char pattern[] = "ould"; //pattern to search for 

// find all lines matching the pattern:
int main()
{
    char line [MAXLINE];
    int found = 0;

    while(getline(line, MAXLINE) > 0)
        if (strindex(line, pattern) >= 0){
            printf("%s", line);
            found++;
        }
    return found;
}

// getline: get line into s, return length
int getline(char s[], int lim)
{
    int c, i;

    i = 0;
    while(--lim > 0 && (c=getchar()) != EOF && c != '\n')
        s[i++] = c;
    if (c == '\n')
        s[i++] = c;
    s[i] = '\0';
    return i;
}

//strindex: return index of t in s, -1 if none
int strindex(char s[], char t[])
{
    int i, j, k;

    for (i = 0; s[i] != '\0'; i++){
        for (j = i, k = 0; t[k] != '\0' && s[j] == t[k]; j++, k++);
        if (k > 0 && t[k] == '\0')
            return i;
    }
    return -1;
}

- Each function definiton has the form:
	- return-type function-name(argument declarations)
	  {
			declarations and statements
	  }
- various parts may be absent; a minimal function is 
	- dummy () {}
	- this is a do nothing function
	- can be useful as a placeholder
- a program is just a set of definitions of variables and functions
- communication between the functions is by arguments and values returned by the functions
	- and through external variables
- functions can occur in any order in the source file
	- the source program can be split into multiple files (so long as no function is split)
- return statement returns a value from the called function to its caller
	- "return expression";
	- the expression will be converted to the return type of the function if necessary
- the calling function is free to ignore the returned value
- if a function fails to return a value, its value is garbage
- multiple source files can be called upon using cc from terminal
	- ex. cc main.c getline.c strindex.C
	- it compiles the 3 files, and results in 3 .o files (object files)

4.2 Functions Returning Non-Integers
- atoi and atof
	- converts strings to numerical values
- atoi (ascii to int)
	- a function used to convert a string representing an integer (in ASCII format) into an actual integer data type. 
	- It takes a string as its argument and returns an integer
	- ex. int atoi(const char *str);
- atof (ascii to floatint-point)
	- a function used to convert a string representing a floating-point number (in ASCII format) into a floating-point data type, typically a double
	- ex. double atof(const char *str);
- these are useful for parsing and converting user input or data read from files where numbers are represented as strings

#include <ctype.h>
double my_atof(char s[])
{
    double val, power;
    int i, sign;
    
    for (i = 0; isspace(s[i]); i++); //skip white space
    sign = (s[i] == '-') ? -1 : 1;
    if (s[i] == '+' || s[i] == '-')
    i++;
    for (val = 0.0; isdigit(s[i]); i++)
        val = 10.0 * val + (s[i] - '0');
    if (s[i] == '.')
        i++;
    for (power = 1.0; isdigit(s[i]); i++){
        val = 10.0 * val + (s[i] - '0');
        power *= 10.0;
    }
    return sign * val / power;
}

- double sum, atof(char []);
	- says that sum is a double and that atof is a function that takes one char argument
- atof must be declared and defined consistently
- if atof and the call to it in main have incosistent types, you will get an error
- this can get tricky in separate compilation
- if the function takes arguments, declare them; 
	- if it takes no arguments, use void
// atoi: convert string s to int using atof
int atoi(char[s])
{
	double atof(char s[]);

	return (int) atof(s);
}

4.3 External variables
- A C program consists of a set of external objects, which are either variables or functions
- external variables are defined outside of any function
	- can be available to many Functions
- "external linkage"
	- refers to the property of a variable or function that allows it to be accessed or used from different source files (translation units) in a program. 
	- Variables and functions with external linkage have a global scope, meaning they can be used across multiple files, not just the file in which they are declared.
- apply with caution!
- pushing and popping operators and operands:
while (next operator or operand is not EOF indicator)
	if (number)
		push it
	else if (operator)
		pop operands
		do operation
		push result
	else if (newline)
		pop and print top of stack
	else 
		error



	